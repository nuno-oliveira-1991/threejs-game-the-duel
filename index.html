<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>The Duel</title>

		<style>
			body { margin: 0; }
		</style>

	</head>

	<body>    
		
		<script
			async
			src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
		></script>
		
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.150.1/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
				}
			}
		</script>
		
		<script type="module">
			// Importing Three.js
			import * as THREE from 'three'
			import { Vector3 } from 'three'; // Add this line
			// Importing OrbitControls add-on to help navigate the scene
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
			// Importing Cannon to help with Physics 
			import * as CANNON from 'cannon-es'
			// Importing Cannon to help with Physics 
			import CannonDebugger from 'cannon-es-debugger'
			// Importing Yuka to help with AI behavior 
			import * as YUKA from 'yuka'

			// Setting the scene, camera and renderer
			const scene = new THREE.Scene()
			const camera = new THREE.PerspectiveCamera(
				75,
				window.innerWidth / window.innerHeight,
				0.1,
				1000
			)
			const renderer = new THREE.WebGLRenderer({ antialias: true })
			renderer.shadowMap.enabled = true
			renderer.setSize(window.innerWidth, window.innerHeight)
			document.body.appendChild(renderer.domElement)

			// Enabling navigating the scene
			const controls = new OrbitControls(camera, renderer.domElement)

			// Introducing Axes Helper
			const axesHelper = new THREE.AxesHelper( 5 );
			scene.add( axesHelper );

			const clock = new THREE.Clock();

			// Setting camera position
			camera.position.z = 9
			camera.position.y = 6
			camera.rotation.x = -0.4

			// Creating one light source
			const light = new THREE.DirectionalLight(0xffffff, 1)
			light.position.y = 3
			light.position.z = 2
			light.castShadow = true
			scene.add(light)

			// Setting up physics world
			const physicsWorld = new CANNON.World({
				gravity: new CANNON.Vec3(0, -9.82, 0)
			})

			// Setting Cannon Debugger
			const cannonDebugger = new CannonDebugger(scene, physicsWorld, {})
		
			// Creating a class (box constructor)
			class Box extends THREE.Mesh {
				constructor({ 
					width, 
					height, 
					depth,
					name, 
					color = '#00ff00', 
					velocity = new Vector3(0, 0, 0),
				  position = new Vector3(0, 0, 0),
					maxDistance,
					distanceTraveled,
					standby,
					speed
				}) {
					super(
						new THREE.BoxGeometry(width, height, depth), 
						new THREE.MeshStandardMaterial({ color })
					)

					this.width = width
					this.height = height
					this.depth = depth
					this.name = name
					this.speed = speed

					this.position.set(position.x, position.y, position.z)

					this.right = this.position.x + this.width / 2
					this.left = this.position.x - this.width / 2

					this.bottom = this.position.y - this.height / 2
					this.top = this.position.y + this.height / 2

					this.front = this.position.z + this.depth / 2
					this.back = this.position.z - this.depth / 2

					// Convert the position from THREE.Vector3 to CANNON.Vec3
					this.body = new CANNON.Body({
 				    mass: 10,
 				    shape: new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2)),
						velocity: new CANNON.Vec3(0, 0, 0),
 				  });
 				  this.body.position.copy(new CANNON.Vec3(position.x, position.y, position.z));

					this.velocity = new CANNON.Vec3(velocity.x, velocity.y, velocity.z);
					
					this.maxDistance = maxDistance
					this.distanceTraveled = distanceTraveled
					this.standby = standby
				}

				// Updating the created box object
				updateSides() {
					this.right = this.position.x + this.width / 2
					this.left = this.position.x - this.width / 2

					this.bottom = this.position.y - this.height / 2
					this.top = this.position.y + this.height / 2

					this.front = this.position.z + this.depth / 2
					this.back = this.position.z - this.depth / 2
				}

				update(delta) {
					this.updateSides()

					this.position.x += this.velocity.x
					this.position.z += this.velocity.z

					// Convert the position updates from THREE.Vector3 to CANNON.Vec3
						const newPosition = new CANNON.Vec3(
  				  this.position.x,
  				  this.position.y,
  				  this.position.z
  				);

  				// Update the position using the converted value
  				this.body.position.copy(newPosition);
				}
			} 
			
			// Creating the Ground
			const ground = new Box({
				width: 10,
				height: 0.1,
				depth: 10,
				name: "ground",
				color: "#808080",
				position: {
					x: 0,
					y: -0.55,
					z: 0
				}
			})
			ground.receiveShadow = true
			scene.add(ground)
			// Ground bounding box
			let groundBB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3())
			groundBB.setFromObject(ground)
			// Creating the Ground as a physics body
			ground.body.mass = 0
    	physicsWorld.addBody(ground.body);

			// Creating Cube 1
			const cube1 = new Box({
				width: 1,
				height: 1,
				depth: 1,
				name: "cube1",
				velocity: new CANNON.Vec3(0, 0, 0),
				position: {
					x: -3,
					y: 0,
					z: 3
				}
			})
			cube1.castShadow = true
			scene.add(cube1)
			// Cube 1 bounding box
			let cube1BB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3())
			cube1BB.setFromObject(cube1)
			// setting Cube 1 as a physics body
			physicsWorld.addBody(cube1.body)

			// Creating Projectile 1
			let projectile1 = new Box({
				width: 0.1,
				height: 0.1,
				depth: 0.1,
				color: "#ff0000",
				velocity:  new CANNON.Vec3(0, 0, 0),
				maxDistance: 4,
				distanceTraveled: 0,
				standby: true,
				speed: 6
			})
			projectile1.receiveShadow = true
			scene.add(projectile1)
			// Create the bounding box for projectile1
			let projectile1BB = new THREE.Box3().setFromObject(projectile1);
			// setting Projectile 1 as a physics body
			physicsWorld.addBody(projectile1.body)

			// Creating Cube 2
			const cube2 = new Box({
				width: 1,
				height: 1,
				depth: 1,
				color: '#0000ff',
				velocity: new CANNON.Vec3(0, 0, 0),
				position: {
					x: 3,
					y: 0,
					z: -3
				} 
			})
			cube2.castShadow = true
			scene.add(cube2)
			// Cube 2 bounding box
			let cube2BB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3())
			cube2BB.setFromObject(cube2)
			// Setting Cube 2 as a physics body
			physicsWorld.addBody(cube2.body)

			// Detecting box collisions
			function boxCollision({	box1, box2 }) {
				// Detect for collision on the x, y and z axis
				const xCollision = box1.right >= box2.left && box1.left <= box2.right
				const yCollision = box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
				const zCollision = box1.front >= box2.back && box1.back <= box2.front

				return xCollision && yCollision && zCollision
			}
			
			// Function to shoot projectile
			function shootProjectile(projectile, projectileBB, shooter) {
			  if (projectile.standby) {
				
			    console.log("fire!")
			    projectile.standby = false
			    projectile.velocity = new THREE.Vector3(0, 0, 4)
					
			    updateProjectilePosition(projectile, projectileBB, shooter)
			  }
			}
			
			// Function to update projectile position
			function updateProjectilePosition(projectile, projectileBB, shooter) {
			  let clock = new THREE.Clock()
				let initialPosition = projectile.position.clone()
			  let currentPosition = new THREE.Vector3(projectile.position.x, projectile.position.y, projectile.position.z)
			  let maxDistanceReached = false
			  let displacement = new THREE.Vector3(0, 0, 0)
				let initialDirection = new THREE.Vector3(0, 0, 1)
  			initialDirection.applyQuaternion(shooter.quaternion)

			  function animate() {
			    let deltaTime = clock.getDelta()
					projectile.distanceTraveled += displacement.length()
					displacement.copy(initialDirection).multiplyScalar(projectile.speed * deltaTime)
					currentPosition.x += displacement.x
					currentPosition.y += displacement.y
					currentPosition.z += displacement.z
					projectile.position.set(currentPosition.x, currentPosition.y, currentPosition.z)
					projectile.body.position.set(projectile.position)
					projectile.updateMatrixWorld()
					projectileBB.setFromObject(projectile)

			    // Check if the distance traveled by the projectile exceeds the maximum distance
			    if (!maxDistanceReached && projectile.distanceTraveled >= projectile.maxDistance) {
			      console.log("Max distance reached")
			      maxDistanceReached = true
						projectile.standby = true
			      projectile.distanceTraveled = 0    
			    }
				
			    if (!maxDistanceReached) {
			      requestAnimationFrame(animate)
			    }
			  }
			
			  animate();
			}

			// Setting Cube 1 control keys
			const keys = {
				a: {
					pressed: false
				},
				d: {
					pressed: false
				},
				w: {
					pressed: false
				},
				s: {
					pressed: false
				},
				b: {
					pressed: false
				},
				m: {
					pressed: false
				},
				h: {
					pressed: false
				},
				n: {
					pressed: false
				}
			}

			// Controls detection
			window.addEventListener("keydown", (event) => {
				switch (event.code) {
					case "KeyA":
						keys.a.pressed = true
						break
					case "KeyD":
						keys.d.pressed = true
						break
					case "KeyW":
						keys.w.pressed = true
						break
					case "KeyS":
						keys.s.pressed = true
						break
					case "KeyB":
						keys.b.pressed = true
						break
					case "KeyM":
						keys.m.pressed = true
						break

					case "KeyN":
						keys.n.pressed = true
						break
				}
			})
			window.addEventListener("keyup", (event) => {
				switch (event.code) {
					case "KeyA":
						keys.a.pressed = false
						break
					case "KeyD":
						keys.d.pressed = false
						break
					case "KeyW":
						keys.w.pressed = false
						break
					case "KeyS":
						keys.s.pressed = false
						break
					case "KeyB":
						keys.b.pressed = false
						break
					case "KeyM":
						keys.m.pressed = false
						break
					case "KeyN":
						keys.n.pressed = false
						break
				}
			})
			window.addEventListener("keypress", (event) => {
				if (event.code === "KeyH") shootProjectile(projectile1, projectile1BB, cube1)
			})
		
			// Animation loop
			function animate() {
				const deltaTime = clock.getDelta();
			  requestAnimationFrame(animate)
			  renderer.render(scene, camera)
			  //cannonDebugger.update()
			
			  ground.update()
			  cube1.update()
			  cube2.update()
				projectile1.update()
				
				// Update Objects' world matrix
			  cube1.updateMatrixWorld()
				cube1BB.setFromObject(cube1)
				cube2.updateMatrixWorld()
				cube2BB.setFromObject(cube2)
				projectile1.updateMatrixWorld()
				projectile1BB.setFromObject(projectile1)

			  // Physics World code
				physicsWorld.fixedStep()

				ground.body.position.copy(ground.position)
				ground.body.quaternion.copy(ground.quaternion)

				cube1.body.position.copy(cube1.position)
				cube1.body.quaternion.copy(cube1.quaternion)

				cube2.body.position.copy(cube2.position)
				cube2.body.quaternion.copy(cube2.quaternion)

				const projectileOffset = new THREE.Vector3(0, 0, 1)

				projectile1.position.copy(new THREE.Vector3(
				  cube1.position.x,
				  cube1.position.y,
				  cube1.position.z + projectileOffset
				));
				projectile1.body.position.copy(projectile1.position)

				if (projectile1.standby) {
				  // Apply cube1's rotation to projectile1 when in standby mode
					projectile1.quaternion.copy(cube1.quaternion)
				  projectile1.body.quaternion.copy(projectile1.quaternion)
					// Update the position of projectile1 relative to cube1
					const relativePosition = projectileOffset.clone().applyQuaternion(cube1.quaternion)
				  projectile1.position.copy(cube1.position).add(relativePosition)
				  projectile1.body.position.copy(projectile1.position)
				}
				
			  // Movement code
				if (keys.a.pressed) cube1.position.x += -0.03
				else if (keys.d.pressed) cube1.position.x += 0.03
				else cube1.velocity.x = 0

				if (keys.w.pressed) cube1.position.z += -0.03
				else if (keys.s.pressed) cube1.position.z += 0.03
				else cube1.velocity.z = 0

				if (keys.b.pressed) cube1.rotation.y += -0.03
				else if (keys.m.pressed) cube1.rotation.y += 0.03
				else cube1.velocity.y = 0

			
			  // Collision code
				groundBB.copy(ground.geometry.boundingBox).applyMatrix4(ground.matrixWorld)
			  cube1BB.copy(cube1.geometry.boundingBox).applyMatrix4(cube1.matrixWorld)
			  cube2BB.copy(cube2.geometry.boundingBox).applyMatrix4(cube2.matrixWorld)
			  projectile1BB.copy(projectile1.geometry.boundingBox).applyMatrix4(projectile1.matrixWorld)
			
				if (boxCollision({
			    box1: cube1,
			    box2: cube2
			  })) {
			    console.log("Box collision detected")
			  } else if (boxCollision({
					box1: projectile1,
					box2: cube2
				})) {
					console.log("projectile collision detected")
				}

				// Apply forces to cubes
    const collisionForce = 10;
    const collisionNormal = new CANNON.Vec3(0, 1, 0); // Assuming a flat ground surface

    const cube1Body = cube1.body;
    const cube2Body = cube2.body;

    // Apply force to cube1 in the direction of the collision normal
    cube1Body.applyForce(collisionNormal.scale(collisionForce), cube1Body.position);

    // Apply equal and opposite force to cube2
    cube2Body.applyForce(collisionNormal.scale(-collisionForce), cube2Body.position);
			
			}

			animate();

		</script>
    
	</body>
</html>